<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>2</storyId>
    <title>Storage Backend and API</title>
    <status>Draft</status>
    <generatedAt>2025-10-28</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-encrypted-storage-2.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer using IdentiKey Tools</asA>
    <iWant>a unified API for encrypted storage with pluggable backends</iWant>
    <soThat>I can store/retrieve encrypted blobs via content hash without coupling to a specific storage system</soThat>
    <tasks>
### Phase 1: Storage Adapter Interface (AC: #1)
- Create `src/storage/adapter.ts` with StorageAdapter interface definition (AC: #1)
- Create `src/types/storage-config.ts` with MinioConfig and StorageConfig types (AC: #1)
- Document interface contract (put/get/exists/delete semantics) (AC: #1)

### Phase 2: MinIO Adapter Implementation (AC: #2, #3, #4, #5, #6)
- Install dependency: `bun add minio` (AC: #2)
- Create `src/storage/minio-adapter.ts` implementing StorageAdapter (AC: #2)
- Implement `put(key, data)`: upload blob to bucket at key (AC: #3)
- Implement `get(key)`: download blob, convert stream to Buffer (AC: #4)
- Implement `exists(key)`: use statObject, catch 404, return boolean (AC: #5)
- Implement `delete(key)`: call removeObject (AC: #6)
- Add MinIO client configuration via environment variables (AC: #2)
- Write unit tests: `tests/unit/storage/minio-adapter.test.ts` (mock MinIO client) (AC: #3, #4, #5, #6)

### Phase 3: Main EncryptedStorage API (AC: #7, #8, #9, #10, #11, #15)
- Create `src/api/encrypted-storage.ts` with EncryptedStorage class (AC: #7)
- Implement `put()`: encrypt → buildHeader → concat → SHA-256 hash → storage.put() (AC: #7, #15)
- Implement `get()`: storage.get() → parseHeader → lookup key → decrypt → verify checksum (AC: #8, #15)
- Implement `getMetadata()`: storage.get() → parseHeader → return metadata only (AC: #9)
- Implement `exists()`: proxy to storage.exists() (AC: #10)
- Implement `delete()`: proxy to storage.delete() (AC: #11)
- Add SHA-256 utility for content hash computation (AC: #15)
- Write unit tests: `tests/unit/api/encrypted-storage.test.ts` (mock storage adapter) (AC: #7-#11)

### Phase 4: Key Management Enhancement (AC: #12, #14)
- Enhance `src/keypair.ts` with KeyManager class (AC: #12)
- Implement `addKey(publicKey, privateKey)`: compute fingerprint, store in Map (AC: #12)
- Implement `getPrivateKey(fingerprint)`: lookup from Map, throw if not found (AC: #12, #14)
- Implement `hasKey(fingerprint)`: check Map membership (AC: #12)
- Write unit tests: `tests/unit/keypair.test.ts` (expand existing tests) (AC: #12, #14)

### Phase 5: Integration Testing (AC: #13, #14)
- Setup Docker Compose with MinIO service for tests (AC: #13)
- Create `.env.test` with MinIO connection config (AC: #13)
- Write `tests/integration/e2e-flow.test.ts`: put → get → verify (AC: #13)
- Write `tests/integration/minio.test.ts`: MinIO CRUD operations (AC: #13)
- Test error scenarios: missing key, backend unavailable, corrupted blob (AC: #14)
- Test large file handling (>10MB blob) (AC: #13)
- Test concurrent operations (multiple puts/gets) (AC: #13)

### Phase 6: Configuration and Documentation (AC: #2)
- Create `.env.local.example` with MinIO config template (AC: #2)
- Document MinIO Docker setup in tech spec or README (AC: #2)
- Add environment variable validation on EncryptedStorage initialization (AC: #2)
    </tasks>
  </story>

  <acceptanceCriteria>
1. **AC1:** `StorageAdapter` interface defines `put(key, data)`, `get(key)`, `exists(key)`, `delete(key)` methods
2. **AC2:** `MinioAdapter` implements StorageAdapter using MinIO client v8.x
3. **AC3:** MinioAdapter PUT stores blob at content hash key, returns void on success
4. **AC4:** MinioAdapter GET retrieves blob by content hash, returns Buffer
5. **AC5:** MinioAdapter EXISTS checks blob presence, returns boolean
6. **AC6:** MinioAdapter DELETE removes blob by content hash
7. **AC7:** `EncryptedStorage.put(plaintext, publicKey, metadata?)` encrypts, builds header, stores blob, returns content hash
8. **AC8:** `EncryptedStorage.get(contentHash, privateKey?)` retrieves blob, parses header, looks up key by fingerprint, decrypts, verifies checksum if present
9. **AC9:** `EncryptedStorage.getMetadata(contentHash)` returns metadata without decrypting ciphertext
10. **AC10:** `EncryptedStorage.exists(contentHash)` proxies to storage backend
11. **AC11:** `EncryptedStorage.delete(contentHash)` proxies to storage backend
12. **AC12:** `KeyManager` class stores keypairs indexed by fingerprint, provides `addKey()` and `getPrivateKey(fingerprint)` methods
13. **AC13:** Integration test: full E2E flow (put → get → verify plaintext matches) against local MinIO
14. **AC14:** Error handling: key not found throws descriptive error; backend failures propagate correctly
15. **AC15:** Content hash = SHA-256(complete blob including header), verifiable on retrieval
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/tech-spec.md" title="Technical Specification" section="Storage Adapter Interface">
        Abstract StorageAdapter interface with put(key, data), get(key), exists(key), delete(key) methods. All async, all throw on errors. Foundation for pluggable backend architecture.
      </doc>
      <doc path="docs/tech-spec.md" title="Technical Specification" section="MinIO Adapter Implementation">
        Complete MinioAdapter class implementing StorageAdapter. Constructor takes config (endpoint, port, useSSL, accessKey, secretKey, bucket). put() uses client.putObject(), get() uses client.getObject() with stream-to-buffer conversion, exists() uses statObject with try/catch, delete() uses removeObject(). Example code provided in lines 315-355.
      </doc>
      <doc path="docs/tech-spec.md" title="Technical Specification" section="Main API Implementation">
        EncryptedStorage class orchestrates full workflow. Constructor takes StorageAdapter and KeyManager. put() method: encrypt plaintext, build header with fingerprint, concat blob, SHA-256 hash blob, store via adapter, return hash. get() method: retrieve blob, parse header, lookup key by fingerprint, decrypt, verify checksum. Metadata-only retrieval skips decryption.
      </doc>
      <doc path="docs/tech-spec.md" title="Technical Specification" section="Key Management">
        KeyManager class stores Map&lt;fingerprint, privateKey&gt;. addKey() computes fingerprint via SHA-256, stores mapping. getPrivateKey() throws descriptive error if key not found. Security note: private keys unencrypted in-memory for MVP, should be encrypted at rest post-MVP.
      </doc>
      <doc path="docs/tech-spec.md" title="Technical Specification" section="Development Setup">
        MinIO Docker setup: `docker run -d -p 9000:9000 -p 9001:9001 --name minio -e MINIO_ROOT_USER=minioadmin -e MINIO_ROOT_PASSWORD=minioadmin minio/minio server /data --console-address ":9001"`. Environment variables for config: STORAGE_BACKEND, MINIO_ENDPOINT, MINIO_PORT, MINIO_ACCESS_KEY, MINIO_SECRET_KEY, MINIO_BUCKET, MINIO_USE_SSL.
      </doc>
      <doc path="docs/architecture/content-addressable-encrypted-storage.md" title="Architecture" section="Component Design">
        Storage layer separates concerns: StorageAdapter interface enables backend swapping (MinIO, S3, filesystem). EncryptedStorage orchestrates encryption + storage + key management. Content addressing via SHA-256(complete blob) prevents correlation attacks by hashing ciphertext not plaintext.
      </doc>
      <doc path="docs/epics.md" title="Epic Breakdown" section="Story 2 Summary">
        Story 2 builds on Story 1 crypto primitives. Delivers MinIO adapter, EncryptedStorage API, and KeyManager enhancements. Enables full put/get workflows with automatic key selection via fingerprint lookup. 5 story points, Weeks 2-3 timeline. Depends on Story 1 completion.
      </doc>
    </docs>
    <code>
      <artifact path="src/keypair.ts" kind="module" symbol="KeyPair interface and utilities" lines="1-37" reason="Existing keypair infrastructure - Story 2 adds KeyManager class here. Interface and serialization helpers (toHex) are foundational for fingerprint-based key storage.">
      </artifact>
      <artifact path="src/keypair.test.ts" kind="test" symbol="keypair test patterns" lines="1-65" reason="Existing Vitest test structure - Story 2 expands these tests to cover KeyManager. Shows testing patterns for key operations and error cases.">
      </artifact>
      <artifact path="src/index.ts" kind="module" symbol="public API exports" lines="1-29" reason="Current export structure - Story 2 adds EncryptedStorage, StorageAdapter, MinioAdapter exports here. Shows module organization pattern.">
      </artifact>
      <artifact path="docs/stories/1-1-core-encryption-infrastructure.context.xml" kind="context" symbol="Story 1 context" lines="full-file" reason="CRITICAL DEPENDENCY: Story 2 requires Story 1 completion. Needs: encrypt(), decrypt(), computeFingerprint(), buildHeader(), parseHeader(), BlobMetadata schema. Story 2 cannot proceed until these are implemented.">
      </artifact>
    </code>
    <dependencies>
      <typescript>
        <package name="minio" version="^8.0.6" status="missing">MinIO S3-compatible client - MUST BE INSTALLED via `bun add minio`</package>
        <package name="tweetnacl" version="^1.0.3" status="installed">Crypto primitives from Story 1 - encrypt/decrypt functions</package>
        <package name="zod" version="^4.1.12" status="installed">Schema validation from Story 1 - header validation</package>
        <package name="cbor" version="needs-install" status="missing">CBOR encoding from Story 1 - metadata serialization</package>
        <package name="@types/node" version="^24.9.1" status="installed">Node.js types for crypto.createHash (SHA-256 content hashing)</package>
      </typescript>
      <devDependencies>
        <package name="vitest" version="^4.0.4" status="installed">Test runner for unit and integration tests</package>
        <package name="tsdown" version="^0.15.9" status="installed">Build tool</package>
      </devDependencies>
      <infrastructure>
        <service name="minio" type="docker" status="needs-setup">
          MinIO Docker container for integration tests. Required ports: 9000 (API), 9001 (Console). Default credentials: minioadmin/minioadmin. Bucket: encrypted-blobs. Setup command documented in tech spec.
        </service>
      </infrastructure>
    </dependencies>
  </artifacts>

  <constraints>
- CRITICAL: Story 1 must be COMPLETE before Story 2 implementation - requires encrypt(), decrypt(), buildHeader(), parseHeader(), computeFingerprint()
- StorageAdapter interface MUST be async - all methods return Promise
- MinIO get() returns stream - MUST convert to Buffer via helper function
- Content hash = SHA-256(complete blob including header) NOT SHA-256(plaintext) - prevents correlation attacks
- KeyManager stores Map&lt;fingerprint, privateKey&gt; - fingerprint is 64-char hex SHA-256
- Error handling: key not found MUST throw descriptive error with fingerprint
- Backend errors MUST propagate with context (operation, key, original error)
- Environment variables required: MINIO_ENDPOINT, MINIO_PORT, MINIO_ACCESS_KEY, MINIO_SECRET_KEY, MINIO_BUCKET
- All imports MUST use .js extension (TypeScript ESM requirement per tsconfig)
- Integration tests require MinIO Docker container running - check connection before tests
- Test files: unit tests co-located with source (.test.ts), integration tests in tests/integration/
- Public API classes exported via src/index.ts
- Follow strict TypeScript settings from tsconfig.json
  </constraints>

  <interfaces>
    <interface name="StorageAdapter" kind="interface" signature="interface StorageAdapter { put(key: string, data: Buffer): Promise&lt;void&gt;; get(key: string): Promise&lt;Buffer&gt;; exists(key: string): Promise&lt;boolean&gt;; delete(key: string): Promise&lt;void&gt;; }" path="src/storage/adapter.ts (to be created)">
      Abstract interface for pluggable storage backends - enables swapping MinIO for S3, filesystem, etc without API changes
    </interface>
    <interface name="MinioAdapter" kind="class" signature="class MinioAdapter implements StorageAdapter { constructor(config: MinioConfig); }" path="src/storage/minio-adapter.ts (to be created)">
      MinIO implementation of StorageAdapter - wraps minio npm client with CRUD operations, handles stream-to-buffer conversion
    </interface>
    <interface name="EncryptedStorage" kind="class" signature="class EncryptedStorage { constructor(storage: StorageAdapter, keyManager: KeyManager); put(plaintext: Buffer, publicKey: Uint8Array, metadata?: Partial&lt;BlobMetadata&gt;): Promise&lt;string&gt;; get(contentHash: string, privateKey?: Uint8Array): Promise&lt;Buffer&gt;; getMetadata(contentHash: string): Promise&lt;BlobMetadata&gt;; exists(contentHash: string): Promise&lt;boolean&gt;; delete(contentHash: string): Promise&lt;void&gt;; }" path="src/api/encrypted-storage.ts (to be created)">
      Main API orchestrating encryption, header management, content hashing, and storage operations
    </interface>
    <interface name="KeyManager" kind="class" signature="class KeyManager { addKey(publicKey: Uint8Array, privateKey: Uint8Array): void; getPrivateKey(fingerprint: string): Promise&lt;Uint8Array&gt;; hasKey(fingerprint: string): boolean; }" path="src/keypair.ts (to be enhanced)">
      Key management class storing fingerprint-to-privateKey mappings for automatic key lookup during decryption
    </interface>
    <interface name="MinioConfig" kind="interface" signature="interface MinioConfig { endpoint: string; port: number; useSSL: boolean; accessKey: string; secretKey: string; bucket: string; }" path="src/types/storage-config.ts (to be created)">
      Configuration type for MinIO adapter initialization
    </interface>
    <interface name="encrypt (from Story 1)" kind="function" signature="encrypt(plaintext: Buffer, publicKey: Uint8Array): Promise&lt;Buffer&gt;" path="src/crypto/encryptor.ts (Story 1 dependency)">
      Story 1 encryption function - required for EncryptedStorage.put()
    </interface>
    <interface name="decrypt (from Story 1)" kind="function" signature="decrypt(ciphertext: Buffer, privateKey: Uint8Array): Promise&lt;Buffer&gt;" path="src/crypto/decryptor.ts (Story 1 dependency)">
      Story 1 decryption function - required for EncryptedStorage.get()
    </interface>
    <interface name="buildHeader (from Story 1)" kind="function" signature="buildHeader(metadata: BlobMetadata, fingerprint: string): Buffer" path="src/header/serialize.ts (Story 1 dependency)">
      Story 1 header serialization - required for EncryptedStorage.put()
    </interface>
    <interface name="parseHeader (from Story 1)" kind="function" signature="parseHeader(blob: Buffer): { header: BlobHeader; ciphertextOffset: number }" path="src/header/parse.ts (Story 1 dependency)">
      Story 1 header parsing - required for EncryptedStorage.get() and getMetadata()
    </interface>
    <interface name="computeFingerprint (from Story 1)" kind="function" signature="computeFingerprint(publicKey: Uint8Array): string" path="src/header/fingerprint.ts (Story 1 dependency)">
      Story 1 fingerprint computation - required for KeyManager.addKey()
    </interface>
  </interfaces>

  <tests>
    <standards>
      Use Vitest test runner (bun test). Unit tests co-located with source files (.test.ts suffix). Integration tests in tests/integration/ directory. Mock external dependencies in unit tests (MinIO client, StorageAdapter). Integration tests require real MinIO Docker container. Test both happy paths and error cases. Use describe/it blocks, expect assertions. Test async operations with async/await. Verify error messages are descriptive. Performance benchmarks: 1MB encrypt+upload &lt;500ms, download+decrypt &lt;300ms.
    </standards>
    <locations>
      - src/storage/minio-adapter.test.ts (unit tests with mocked MinIO client)
      - src/api/encrypted-storage.test.ts (unit tests with mocked StorageAdapter)
      - src/keypair.test.ts (expand existing tests for KeyManager)
      - tests/integration/e2e-flow.test.ts (full workflow against real MinIO)
      - tests/integration/minio.test.ts (MinIO CRUD operations)
      - tests/integration/large-files.test.ts (>10MB blobs, concurrent operations)
    </locations>
    <ideas>
      - AC1: Test StorageAdapter interface contract - all methods defined, correct signatures
      - AC2-6: Unit test MinioAdapter methods with mocked client - put succeeds, get returns buffer, exists true/false, delete succeeds, error handling
      - AC7: Unit test EncryptedStorage.put() - encrypts plaintext, builds header, computes SHA-256 hash, calls storage.put with hash key, returns hash
      - AC8: Unit test EncryptedStorage.get() - retrieves blob, parses header, looks up key by fingerprint, decrypts, verifies checksum if present
      - AC9: Unit test getMetadata() - retrieves blob, parses header, returns metadata without decryption
      - AC10-11: Unit test exists/delete proxy to storage backend
      - AC12: Unit test KeyManager - addKey stores mapping, getPrivateKey retrieves key, throws on missing key, hasKey checks membership
      - AC13: Integration test E2E - generate keypair, encrypt data, put to MinIO, get by hash, decrypt, verify plaintext matches
      - AC14: Test error cases - missing key throws with fingerprint, backend connection failure propagates, corrupted blob rejected
      - AC15: Test content hash - same plaintext with different keys produces different hashes, hash verification on retrieval
      - Performance: Benchmark 1MB, 10MB, 100MB files against targets
      - Concurrency: Test multiple simultaneous puts/gets
    </ideas>
  </tests>
</story-context>

